# -*- coding: utf-8 -*-
"""Cópia de Customers_classification

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ASEbE_b7Ws5DFFpbPjaP0j5_rVjm_ir3
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import LabelEncoder

import pandas as pd

# Lê o arquivo CSV
df = pd.read_csv('/content/CLUSTER.csv')

# Remove linhas com valores ausentes (NaN)
df = df.dropna()

# Remove as linhas onde 'Cod Cliente' é igual a 1
df = df[df['Cod Cliente'] != 1]

# Remove as colunas especificadas
colunas_para_remover = ['Cod Filial', 'Quantidade de Compras', 'Valor Total de Vendas']
df.drop(columns=colunas_para_remover, inplace=True)

# Exibe as primeiras linhas do DataFrame atualizado
df.head()

obj_padronizado = StandardScaler().fit(df)
df_padronizado = obj_padronizado.transform(df)
df_padronizado = pd.DataFrame(df_padronizado)
df_padronizado.columns = ['Cod Cliente','Produto Mais Vendido','Idade', 'Genero']
df_padronizado.head()
obj_normalizacao = MinMaxScaler().fit(df)
df_normalizado = obj_normalizacao.transform(df)
df_normalizado = pd.DataFrame(df_normalizado)
df_normalizado.columns = ['Cod Cliente','Produto Mais Vendido','Idade', 'Genero']
df_normalizado.describe()

# Imprime as contagens para 'Genero'
print("Contagem por Gênero:")
print(df['Genero'].value_counts())

# Imprime as contagens para 'Produto Mais Vendido'
print("\nContagem por Produto Mais Vendido:")
print(df['Produto Mais Vendido'].value_counts())

df.info()

from sklearn.cluster import KMeans  # Importe a classe KMeans

WCSS = []
X = df.iloc[:, 1:].values
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, init='k-means++', random_state=0)
    kmeans.fit(X)
    WCSS.append(kmeans.inertia_)

import matplotlib.pyplot as plt  # Certifique-se de importar a biblioteca de plotagem
plt.plot(range(1, 11), WCSS)
plt.title('Método do Cotovelo')
plt.xlabel('Número de grupos')
plt.ylabel('Valor WCSS')
plt.show()

kmeansmodel = KMeans(n_clusters = 4, init='k-means++', random_state=0)
y_kmeans = kmeansmodel.fit_predict(X)

plt.scatter(X[y_kmeans == 0,0], X[y_kmeans == 0,1], s=80, c = 'red', label='Customer 1')
plt.scatter(X[y_kmeans == 1,0], X[y_kmeans == 1,1], s=80, c = 'green', label='Customer 2')
plt.scatter(X[y_kmeans == 2,0], X[y_kmeans == 2,1], s=80, c = 'blue', label='Customer 3')
plt.scatter(X[y_kmeans == 3,0], X[y_kmeans == 3,1], s=80, c = 'grey', label='Customer 4')
plt.title('Grupo de clientes')
plt.legend()
plt.show()

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Plota os clusters
ax.scatter(X[y_kmeans == 0, 0], X[y_kmeans == 0, 1], X[y_kmeans == 0, 2], c='red', label='Customer 1')
ax.scatter(X[y_kmeans == 1, 0], X[y_kmeans == 1, 1], X[y_kmeans == 1, 2], c='green', label='Customer 2')
ax.scatter(X[y_kmeans == 2, 0], X[y_kmeans == 2, 1], X[y_kmeans == 2, 2], c='blue', label='Customer 3')
ax.scatter(X[y_kmeans == 3, 0], X[y_kmeans == 3, 1], X[y_kmeans == 3, 2], c='grey', label='Customer 4')

from sklearn.metrics import davies_bouldin_score
from sklearn.metrics import calinski_harabasz_score

dbs_score = davies_bouldin_score(X, y_kmeans)
ch_score = calinski_harabasz_score(X, y_kmeans)
within_cluster_ss = kmeans.inertia_ / kmeans.n_clusters
between_cluster_ss = kmeans.inertia_ - within_cluster_ss
print(dbs_score)
print(ch_score)
print(within_cluster_ss)
print(between_cluster_ss / kmeans.n_clusters)

df['Cluster'] = y_kmeans + 1

print(df)

cluster_counts = pd.Series(y_kmeans).value_counts()
print(cluster_counts)

pip install plotly

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Adapte conforme necessário
df['Cluster'] = y_kmeans  # Assumindo que os rótulos dos clusters estão em y_kmeans
df['Genero'] = df['Genero']  # Assumindo que os valores 0 e 1 estão na coluna 'Target'

# Cria um DataFrame com a contagem de valores 0 e 1 em cada cluster
count_df = df.groupby(['Cluster', 'Genero']).size().reset_index(name='Count')

# Plota um gráfico de barras
plt.figure(figsize=(10, 6))
sns.barplot(x='Cluster', y='Count', hue='Genero', data=count_df, palette='pastel')
plt.title('Contagem de 0 e 1 em cada Cluster')
plt.xlabel('Cluster')
plt.ylabel('Contagem')
plt.show()

print(df)

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
# Adapte conforme necessário
df['Cluster'] = y_kmeans  # Assumindo que os rótulos dos clusters estão em y_kmeans
df['Idade'] = df['Idade']  # Assumindo que os valores 0 e 1 estão na coluna 'Idade'
# Filtra o DataFrame para cada cluster e calcula a contagem de valores 0 e 1 para a idade
cluster_1_df = df[df['Cluster'] == 0].groupby('Idade').size().reset_index(name='Count')
cluster_2_df = df[df['Cluster'] == 1].groupby('Idade').size().reset_index(name='Count')
cluster_3_df = df[df['Cluster'] == 2].groupby('Idade').size().reset_index(name='Count')
cluster_4_df = df[df['Cluster'] == 3].groupby('Idade').size().reset_index(name='Count')
# Configuração da figura com subplots
fig, axes = plt.subplots(2, 2, figsize=(15, 10))
# Plota os gráficos de barras para cada cluster
sns.barplot(x='Idade', y='Count', data=cluster_1_df, ax=axes[0, 0], palette='pastel')
axes[0, 0].set_title('Cluster 1')
sns.barplot(x='Idade', y='Count', data=cluster_2_df, ax=axes[0, 1], palette='pastel')
axes[0, 1].set_title('Cluster 2')
sns.barplot(x='Idade', y='Count', data=cluster_3_df, ax=axes[1, 0], palette='pastel')
axes[1, 0].set_title('Cluster 3')
sns.barplot(x='Idade', y='Count', data=cluster_4_df, ax=axes[1, 1], palette='pastel')
axes[1, 1].set_title('Cluster 4')
# Ajusta o layout
plt.tight_layout()
plt.show()

# # Agrupar os dados por cluster e gênero e contar o número de pessoas
# agrupado = df.groupby(['Cluster', 'Genero']).size().unstack()

# # Obter os clusters únicos
# clusters_unicos = df['Cluster'].unique()
# num_clusters = len(clusters_unicos)

# largura_barra = 0.4  # Largura das barras

# # Coordenadas para os clusters
# clusters_x = np.arange(num_clusters)

# # Criar o gráfico de barras para "homem"
# plt.bar(clusters_x - largura_barra/2, agrupado[0], width=largura_barra, label='Homem', color='blue')

# # Criar o gráfico de barras para "mulher"
# plt.bar(clusters_x + largura_barra/2, agrupado[1], width=largura_barra, label='Mulher', color='pink')

# # Definir os rótulos dos clusters no eixo x
# plt.xticks(clusters_x, clusters_unicos)

# # Adicione rótulos aos eixos e um título
# plt.xlabel('Clusters')
# plt.ylabel('Quantidade de Pessoas')
# plt.title('Gráfico de Barras: Quantidade de Pessoas por Cluster e Gênero')

# # Adicione uma legenda
# plt.legend()

# # Mostre o gráfico
# plt.show()

# Substitua 'seu_arquivo.csv' pelo nome do arquivo que deseja usar para salvar o DataFrame
nome_arquivo = 'Cluster_Domini.csv'

# Use o método 'to_csv' para salvar o DataFrame em um arquivo CSV
df.to_csv(nome_arquivo, index=False)

from google.colab import files

# Faça o download do arquivo CSV para a sua máquina local
files.download(nome_arquivo)